using System.Reflection;

namespace Bootsharp.Publish;

internal class InteropMarshaller
{
    private readonly Dictionary<string, string> generatedByName = [];

    public string Marshal (Type type)
    {
        if (IsNestedArrayWorkaround(type)) return "";
        var methodName = $"Marshal_{GetMarshalId(type)}";
        if (generatedByName.ContainsKey(methodName)) return methodName;
        generatedByName[methodName] = GenerateMarshalMethod(methodName, type);
        return methodName;
    }

    public string Unmarshal (Type type)
    {
        if (IsNestedArrayWorkaround(type)) return "";
        var methodName = $"Unmarshal_{GetMarshalId(type)}";
        if (generatedByName.ContainsKey(methodName)) return methodName;
        generatedByName[methodName] = GenerateUnmarshalMethod(methodName, type);
        return methodName;
    }

    public IReadOnlyCollection<string> GetGenerated () => generatedByName.Values;

    private bool IsNestedArrayWorkaround (Type type) =>
        // TODO: Remove once solved https://github.com/elringus/bootsharp/issues/138.
        type.IsArray && !ShouldMarshall(type.GetElementType()!);

    private string GenerateMarshalMethod (string name, Type type)
    {
        var nullable = IsNullable(type) || !type.IsValueType;
        var props = GetMarshaledProperties(type).Select(MarshalProperty);
        return
            $$"""
              private static object {{name}} ({{BuildSyntax(type)}} obj)
              {
                  {{JoinLines([
                      nullable ? "if (obj is null) return null;" : null,
                      $"return new object[] {{ {string.Join(", ", props)} }};"
                  ])}}
              }
              """;

        string MarshalProperty (PropertyInfo prop)
        {
            var type = prop.PropertyType;
            if (!ShouldMarshall(type)) return $"obj.{prop.Name}";
            return "";
        }
        //
        // string MarshalType () { }
        //
        // string MarshalList () { }
        //
        // string MarshalDictionary () { }
    }

    private string GenerateUnmarshalMethod (string name, Type type)
    {
        var stx = BuildSyntax(type);
        return
            $$"""
              private static {{stx}} {{name}} (object raw)
              {
                  
              }
              """;
    }

    //     private static string GenerateCommon () =>
    //         """
    //         private static readonly List<object> list = [];
    //
    //         private static object MarshalList (object obj)
    //         {
    //             list.Clear();
    //         
    //             // Have to resort to enumerable here, because buffer types
    //             // generated by collection expressions can't be casted to non-generic
    //             // IList or ICollection, while casting to IReadOnlyCollection<object>
    //             // won't work for collections where element is of a value type.
    //         
    //             foreach (var element in (System.Collections.IEnumerable)obj)
    //                 list.Add(element);
    //         
    //             return list.ToArray();
    //         }
    //
    //         private static object MarshalDictionary (object obj)
    //         {
    //             var dict = (System.Collections.IDictionary)obj;
    //             var raw = new object[dict.Count];
    //             var idx = 0;
    //         
    //             foreach (System.Collections.DictionaryEntry entry in dict)
    //             {
    //                 raw[idx++] = entry.Key;
    //                 raw[idx++] = entry.Value;
    //             }
    //         
    //             return raw;
    //         }
    //         """;
}
